# cycle-subdivide
CSCI 385 Project 5
Ilana Kim and Sashka Hakakha

Part 1: Implementing subdivision

The subdivide method implements loop subdivision to refine a surface. The method first creates a refined surface object that will be the refined surface R.

 The method then creates a clone vertex for each vertex of the original surface S using the makeVertex method. To put the clone vertices in the right locations, we use the mathematical formula for calculating the new location of a vertex given in the instructions. The implementation of this formula relies on two helper functions, get_neighbors and compute_beta. The get_neighbors function takes in a vertex v and returns the "neighbors" of that vertex, which are the targets of outgoing edges from that vertex. To do this, we find the outgoing edges of a vertex by starting with e,the current edge as v.edge then setting the current edge to current.prev.twin and pushing it onto an array of edges until we get to an edge we have already been to. We then go through the array of edges and push their targets to an array of neighbor vertices. This array of neighboring vertices is returned by the function. The compute_beta function takes in a value k and returns the constant beta given by the equation in the instructions. We implement the vertex cloning by looping through the vertices and computing the new position of the cloned vertex using the positions of the array of neighbors returned by get_neighbors and the constant beta returned by compute_beta. We then set the v.clone attribute to the new vertex in the surface R using R.makeVertex.

 Next, the method creates the split vertices for each edge. The split vertex positions are a weighted average of the positions nearby vertices of S. Specifically for an edge e, these vertices are  p1 = e.source.position, p2 = e.target.position, q1 = e.next.target.position, and q2 = e.twin.next.target.position. To create the split vertices inand put them in the right position, we loop through each edge in S and compute the position using the averaging equation given in the instructions with the positions of p1 p2, q1, and q2. When we do this for an edge, we check if the twin of the edge already has a vertex so that only create one split vertex for an edge and its twin. If the twin already has a vertex, we set the edge's vertex to its twin's vertex, otherwise we create a new vertex using R.makeVertex and we set the e.split attribute to the newly created vertex.

 Next, the method creates the faces for the new surface R using the clone vertices and split vertices that we computed. Creating the faces relies on the split attribute of edges and clone attribute of vertices that we set when we created the split and clone vertices. For each triangular face of S, the subdivision will create 3 clone vertices and 3 split vertices in R and 4 faces. To create the faces, we loop through each face of S, get the ids of the 6 vertices using the split and clone attributes that we set, and then make the four faces using the R.makeFace method. The makeFace method creates the edges of a face and sets their attributes, and when the edges are created, the twin attribute is set as well. The method then returns the new surface R.    

Part 2: Game extension

Our game extension features enemy cycles that move automatically and an endgame. Each cycle is a different color and marks the faces that it crosses. The enemy cycles are instances of a subclass of the cycle class we wrote called autoCycle. We wrote new update and advanceEdgeFace classes for the autoCycle subclass that make the enemy cycles move automatically. This is done using a random number generator to determine whether the cycle turns and which direction it turns. We also added a crossed attribute to the face class to mark whether a face has been crossed by a cycle. If a cycle collides with the color path of a different cycle, the cycle crashes and dies (this is implemented with an "alive" attribute for the cycle class). To make sure that the cycle only dies when it hits the path of a different cycle and not its own path, it changes the crossed attribute of the face to its id. When the cycle crosses a face, it checks whether the face was unmarked, marked by itself, or marked by another cycle. When the game starts or a surface is subdivided, the cycles are placed on a random place on the surface. In addition to the controls given for the player, a player can speed up the enemy cycles by pressing the 'a' key. The player has to try to avoid the paths of the other cycles and wins the game if they are the last cycle to survive.

The screenshots in the folder show the results of the subdivison and the game extension. 
