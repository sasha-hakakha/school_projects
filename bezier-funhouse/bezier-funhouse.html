<!doctype html>
  <html lang="en">
  <head>
    <meta charset="utf-8">
    <title>a Bézier funhouse</title</title>

    <script id="glsl/trace-vs.c" type="x-shader/x-vertex">
      //
      // trace-vs.c
      //
      // Reed College CSCI 385 Computer Graphics Spring 2022
      //
      // This is a vertex shader that is used for rendering a simple
      // ray-traced scene of some spheres and a mirrored object sitting
      // in a room.
      //
      // Most of the ray tracing is performed in its companion fragment shader
      // `trace-fs.c`. The code below basically sends info of the four corners
      // of a quadrilateral so that they can be used as the virtual screen for
      // our ray tracing.
      //
      
      attribute vec4 corner;

      varying vec2  jitter;           // Value in [-1,1]^2 for the ray offset.
      
      uniform vec4  eyePosition;      // Information about the viewer.
      uniform vec4  intoDirection;
      uniform vec4  rightDirection;
      uniform vec4  upDirection;
      
      uniform vec3  lightColor;       // Color of the light.
      uniform vec4  lightPosition;    // Position of the light.

      uniform int   curvedMirror;     // mirror shape (0 = sphere; 1 = curved)
      uniform float sphereData[70];   // Position/size/color of spheres.
      uniform int   numSpheres;       // Number of valid spheres in the above.
      
      uniform float controlPoints[6]; // Control points of the Beziér mirror.
      
      void main(void) {
        // Place in right half of WebGL viewport coordinates.
        gl_Position = vec4(corner.x+0.5, corner.y*2.0, 0.0, 1.0);
        
        // Jitter cast ray by uniform grid of vectors \in [-1,1]^2.
        jitter = vec2(corner.x, corner.y);
      }
    </script>

    <script id="glsl/trace-fs.c" type="x-shader/x-vertex">
      //
      // trace-fs.c
      //
      // Reed College CSCI 385 Computer Graphics Spring 2022
      //
      // This is a fragment shader that colors a pixel by tracing a
      // ray into a simple 3D scene. The scene consists of cubical
      // room with matte-shaded walls, and several glossy spheres.
      // There is also one mirrored object (a sphere or a Bezier
      // "sheet") that reflects the scene to the viewer. There is
      // one light source that illuminates the scene.
      //
      // The code is sent the light color and position, along with
      // the ray tracing projection information from the front end.
      // The key component of that projection info is a "jitter"
      // vec2 that describes where each ray should be traced through
      // the virtual screen.
      //
      // This `jitter` is sent from the vertex shader, giving an
      // (x,y) location chosen uniformly from [-1,1]^2, one value
      // pair for each pixel rendered by WebGL.
      //
      // The code is best further described under `main` and `trace`,
      // and these two functions rely on several functions that
      // compute intersections of a ray with walls, spheres, and the
      // Bezier curved mirror.
      //
      // Several other pieces of information are sent from the front
      // end, specifically 7 floating point values per sphere as
      // the uniform array `sphereData`. These floating point values
      // are described below within a `struct Sphere`, giving the
      // location, size, and material properties of each sphere.
      //
      // There is also an array `curvePoints` which gives the floor
      // 2D points specifying the foorprint of the curved Bezier
      // mirror.
      //
      // Currently, the code uses Sphere #0 as a mirrored surface.
      // This happens in the function `rayIntersectMirror`. Your
      // assignment is to write this code so that the mirror is
      // instead the curved Bezier sheet.
      //
      
      precision highp float;
      precision highp int;
      
      varying vec2  jitter; // Value from [-1,1]^2 for the ray offset.

      uniform vec4  eyePosition;      // Point to start tracing each ray.
      uniform vec4  intoDirection;    // Direction of the camera.
      uniform vec4  rightDirection;   // Camera right.
      uniform vec4  upDirection;      // Camera up.
      
      uniform vec3  lightColor;       // Color of the light.
      uniform vec4  lightPosition;    // Position of the light.

      uniform int   curvedMirror;     // mirror shape (0 = sphere; 1 = curved)
      uniform float sphereData[70];   // Position/size/color of spheres.
      uniform int   numSpheres;       // Number of valid spheres in the above.

      uniform float controlPoints[6]; // Control points of the Beziér mirror.

      #define FAR 10.0
      #define EPSILON 0.000001
      #define ONE_PLUS_TOLERANCE 1.25

      // struct Sphere (* not actually used! *)
      // 
      // This struct serves to remind us of the layout of sphereData.
      // There are seven consecutive floating point values that describe
      // a sphere in the scene.
      //
      struct Sphere {
        float cx;     // Center of the sphere.
        float cy;
        float cz;
        //
        float r;      // Radius of the sphere.
        //
        float red;    // Material of the sphere.
        float green;
        float blue;
      };

      // struct Isect
      //
      // Struct for recording ray-object intersection info.
      //
      struct ISect {
        int yes;        // Is it an intersection? (1 = yes, 0 = no)
        //
        float distance; // If so, what's the distance from the ray's origin?
        vec4  location; // Where did the ray intersect the object?
        vec4  normal;   // What was the surface normal where it intersected?
        //
        vec3 materialColor;  // What are the surface material's properties?
        int  materialGlossy; // Is it glossy? (1 = glossy, 0 = matte)
      };

      ISect NO_INTERSECTION() {
        
        //
        // Returns an ISect struct representing "no intersection" with
        // any scene object. Its `yes` component is set to 0, and the
        // others are filled with bogus values.
        //
        // This always loses in the `bestISect` comparison described
        // below.
        //
        
        return ISect(0, 0.0,
        vec4(0.0,0.0,0.0,0.0),
        vec4(0.0,0.0,0.0,0.0),
        vec3(0.0,0.0,0.0), 0);
      }

      ISect bestISect(ISect info1, ISect info2) {
        
        //
        // Compare two intersections. If they are both `yes`, then
        // it returns the closer of the two.
        //
        // If either is not a `yes` it returns the other.
        //
        
        if (info2.yes == 1
        && (info1.yes == 0
        || info2.distance < info1.distance)) {
          return info2;
        } else {
          return info1;
        }
      }

      ISect rayIntersectPlane(vec4 R, vec4 d, vec4 P, vec4 n) {
        
        //
        // Check if a ray intersects an oriented plane.  Return an
        // `ISect` describing that intersection.
        //
        //    R, d: ray source point and direction.
        //    P, n: plane point and normal.
        //
        
        vec4 du = normalize(d);

        //
        // Check the origin's signed height above the plane.
        //
        float height = dot(R - P, n);
        if (height < EPSILON) {
          return NO_INTERSECTION();
        }

        //
        // Check whether the ray hits the plane.
        //
        float hits = dot(-du, n);
        if (hits < EPSILON) {
          // If the ray is pointing away from the plane...
          return NO_INTERSECTION();
        }

        // It hits the plane!

        //
        // Figure out the distance the plane is away from the ray's origin.
        //
        float distance = (height / hits);
        if (distance < EPSILON) {
          // If we're super-close to the plane, set to a minimum distance.
          distance = EPSILON;
        }

        //
        // Record and return the intersection info.
        //
        ISect isect;
        isect.yes      = 1;
        isect.distance = distance;
        isect.location = R + distance * du;
        isect.normal   = n;
        return isect;
      }

      ISect rayClosestWall(vec4 R, vec4 d) {
        //
        //    R, d: ray source point and direction.          
        //
        // This checks to see if a ray hits any of the 4 walls, and
        // the floor/ceiling of the cubical room housing the
        // scene. Each is axis-aligned:
        //  * The back wall and entrance have a normal of -/+ z.
        //  * The left and right walls have a normal of +/- x.
        //  * The floor and ceiling have a normal of +/- y.
        // Each plane is checked and the closest boundary plane
        // to the emitted ray is recorded and returned.
        //
        // The `ISect` also returns the color of that closest
        // wall. For the floor, the color calculation is
        // complicated. It is a tiling of two colors with a 5 x 5
        // checkerboard pattern. For the entrance, there is a
        // door with a peephole and a door handle. The appropriate
        // material color is set in `materialColor`.
        //
        // The materials of all these are matte and so
        // `materialGlossy` is set to 0.
        //
        
        ISect isect = NO_INTERSECTION();
        isect.materialColor = vec3(0.3,0.2,0.5);

        //
        // floor
        //
        ISect flor = rayIntersectPlane(R, d,
        vec4(0.0,0.0,1.0,1.0),
        vec4(0.0,1.0,0.0,0.0));
        if (flor.yes == 1) {
          // Checkerboard floor pattern.
          vec4 fl = flor.location;
          int i = 0;
          if (fl.x < -0.6) i++;
          if (fl.x < -0.2) i--;
          if (fl.x <  0.2) i++;
          if (fl.x <  0.6) i--;
          if (fl.z <  0.4) i++;
          if (fl.z <  0.8) i--;
          if (fl.z <  1.2) i++;
          if (fl.z <  1.6) i--;
          if (i == 0 || i == 2 || i == -2 || i == -4 || i == 4) {
            flor.materialColor = vec3(0.125, 0.175, 0.25); // dark green
          } else {
            flor.materialColor = vec3(0.125, 0.25, 0.175); // dark blue
          }
          flor.materialGlossy = 0;
        }
        isect = bestISect(isect, flor);

        //
        // left wall
        //
        ISect left = rayIntersectPlane(R, d,
        vec4(-1.0,1.0,1.0,1.0),
        vec4(1.0,0.0,0.0,0.0));
        left.materialColor = vec3(0.6,0.49,0.48); // slate blue
        left.materialGlossy = 0;
        isect = bestISect(isect, left);

        //
        // right wall
        //
        ISect rght = rayIntersectPlane(R, d,
        vec4(1.0,1.0,1.0,1.0),
        vec4(-1.0,0.0,0.0,0.0));
        rght.materialColor = vec3(0.5,0.59,0.48); // olive-ish
        rght.materialGlossy = 0;
        isect = bestISect(isect, rght);

        //
        // back wall
        //
        ISect back = rayIntersectPlane(R, d,
        vec4(0.0,1.0,2.0,1.0),
        vec4(0.0,0.0,-1.0,0.0));
        back.materialColor = vec3(0.60,0.58,0.55); // warm-ish white
        back.materialGlossy = 0;
        isect = bestISect(isect, back);

        //
        // ceiling
        //
        ISect ceil = rayIntersectPlane(R, d,
        vec4(0.0,2.0,1.0,1.0),
        vec4(0.0,-1.0,0.0,0.0));
        ceil.materialColor = vec3(0.5,0.49,0.48); // warm-ish gray
        ceil.materialGlossy = 0;
        isect = bestISect(isect, ceil);

        //
        // entrance
        //
        ISect entr = rayIntersectPlane(R, d,
        vec4(0.0,1.0,0.0,1.0),
        vec4(0.0,0.0,1.0,0.0));
        if (entr.yes == 1) {
          if (abs(entr.location.x) < 0.3 && entr.location.y < 1.4) {
            //
            // The ray hits the door.
            //
            float handlex = entr.location.x - 0.24;
            float handley = entr.location.y - 0.72;
            float eyex = entr.location.x;
            float eyey = entr.location.y - 1.0;
            if (handlex*handlex+handley*handley < 0.04*0.04
            || eyex*eyex+eyey*eyey < 0.01*0.01) {
              //
              // The ray hits the door handle or the peephole.
              //
              entr.materialColor = vec3(0.00,0.00,0.00); // black
            } else {
              //
              // Set to the door color.
              //
              entr.materialColor = vec3(0.43,0.40,0.17); // brown
            }
          } else {
            //
            // Set to the wall color.
            //
            entr.materialColor = vec3(0.43,0.60,0.67);     // blue
          }
        }
        entr.materialGlossy = 0;
        isect = bestISect(isect, entr);

        return isect;
      }

      bool rayHitsSphereBefore(vec4 R, vec4 d, vec4 C, float r, float limit) {
        //
        // Check whether a ray intersects a sphere. Returns a
        // boolean indicating whether the sphere is hit.
        //
        //    R, d: ray source point and direction.
        //    C, r; sphere center point and radius
        //
        vec4 du = normalize(d);
        vec4 toR = R-C;

        // This is calculated carefully on the wikipedia entry for
        // Ray-Sphere intersection.
        //
        float delta1 = -dot(du,toR);
        float delta2 = dot(toR,toR);
        float delta = delta1*delta1 - (delta2 - r*r);
        if (delta > EPSILON) {
          float distance = (delta1 - sqrt(delta));
          if (distance > EPSILON && distance < limit) {
            return true;
          }
        }
        return false;
      }

      // RAY_HITS_SPHERE_BEFORE
      //
      // Below gives the code for a C/GLSL _macro_ whose code gets
      // cut-n-pasted using its template. It is built as a single
      // line and gives a template for when it is used below.
      //
      // The code below checks whether a ray hits a certain sphere in
      // the room scene. The particular sphere is given by an integer
      // INDEX and the sphere's info is accessed from the `sphereData`
      // array of floats. HITS_ANY should be a variable of type `bool`
      // and is set to `true` if the sphere is hit by the ray.
      //
      // The ray is given by an ORIGIN point and DIRECTION vector.
      // The code relies on `rayHitsSphere` to do its work.
      //
      
      #define RAY_HITS_SPHERE_BEFORE(INDEX, ORIGIN, DIRECTION, DISTANCE, HITS_ANY)        \
      if (INDEX >= curvedMirror && INDEX < numSpheres) {		                          \
      float rhs_x = sphereData[INDEX*7+0];                                            \
      float rhs_y = sphereData[INDEX*7+1];                                            \
      float rhs_z = sphereData[INDEX*7+2];                                            \
      float rhs_r = sphereData[INDEX*7+3];                                            \
      vec4  rhs_c = vec4(rhs_x, rhs_y, rhs_z, 1.0);                                   \
      bool rhs_hits = rayHitsSphereBefore(ORIGIN, DIRECTION, rhs_c, rhs_r, DISTANCE); \
      HITS_ANY  = HITS_ANY || rhs_hits;                                               \
    };

    
    bool rayHitsBezierBefore(vec4 R, vec4 d, vec2 cp0, vec2 cp1, vec2 cp2, float distance) {
      //
      // This should return `true` if shooting a ray from point
      // `R` in a direction `d` hits a Bezier mirror before
      // traveling a given `distance`.
      //
      // The mirror is given by control points whose floor
      // coordinates sit at `cp0`, `cp1`, and `cp2`. You can make
      // the mirror have any height you like. My demo used a
      // height of 1.5.
      //
      // This is used to see the mirror's shadow.
      //

      // CHANGE THIS CODE!
      
      return false;  // No shadow.
    }
    
    bool rayHitsMirrorBefore(vec4 R, vec4 d, float distance) {
      bool hits = false;
      if (curvedMirror == 0) {
        RAY_HITS_SPHERE_BEFORE(0, R, d, distance, hits);
      } else {
        vec2 cp0 = vec2(controlPoints[0],controlPoints[1]);
        vec2 cp1 = vec2(controlPoints[2],controlPoints[3]);
        vec2 cp2 = vec2(controlPoints[4],controlPoints[5]);
        hits = rayHitsBezierBefore(R, d, cp0, cp1, cp2, distance);
      }
      return hits;
    }
    
    bool rayHitsSomeSphereBefore(vec4 R, vec4 d, float distance) {
      //
      // Determine whether or not a ray hits some sphere
      // in the scene. Returns a boolean indicating whether
      // some sphere was hit.
      //
      //    R, d: ray source point and direction.
      //
      bool hitsSphere = false;
      RAY_HITS_SPHERE_BEFORE(1, R, d, distance, hitsSphere);
      RAY_HITS_SPHERE_BEFORE(2, R, d, distance, hitsSphere);
      RAY_HITS_SPHERE_BEFORE(3, R, d, distance, hitsSphere);
      RAY_HITS_SPHERE_BEFORE(4, R, d, distance, hitsSphere);
      RAY_HITS_SPHERE_BEFORE(5, R, d, distance, hitsSphere);
      RAY_HITS_SPHERE_BEFORE(6, R, d, distance, hitsSphere);
      RAY_HITS_SPHERE_BEFORE(7, R, d, distance, hitsSphere);
      RAY_HITS_SPHERE_BEFORE(8, R, d, distance, hitsSphere);
      RAY_HITS_SPHERE_BEFORE(9, R, d, distance, hitsSphere);
      return hitsSphere;
    }
    
    vec3 computePhong(vec4 P, vec4 n, vec4 V, vec4 L,
    vec3 mColor, int mGlossy) {
      //
      // Figures out Phong shading of an object at a surface point P with
      // normal n, and with respect to some light at point L, when viewed
      // from point V. The material's properties are specified with
      // `mColor` and `mGlossy`, giving the RGB of the color reflected
      // and whether the material is glossy (set to 1) or matte (set to 0).
      //
      // The surface point might be in shadow, so we check occlusion by
      // seeing whether a ray between the surface point and the light
      // is obstructed by an object in the scene.
      //
      // This returns an RGB vec3 of the Phong shading's color.
      //
      //   P: surface point
      //   n: normal direction at that surface point
      //   V: point from which the surface is being viewed
      //   L: point from which the surface is being illuminated
      //
      //   mColor, mGlossy: material color, shine
      //

      //
      // If in shadow, ambient reflection only.
      //

      float ambientMix   = 0.75;
      vec4  towardsLight = L - P;
      vec3  ambient      = ambientMix * lightColor * mColor;
      //
      float within = length(towardsLight);
      bool occluded = rayHitsSomeSphereBefore(P, towardsLight, within);
      occluded = occluded || rayHitsMirrorBefore(P, towardsLight, within);
      if (occluded) {
        // The surface point is in shadow from the light.
        return ambient;
      }

      //
      // If light is behind the surface, then ambient reflection only.
      //
      vec4  l = normalize(towardsLight);
      if (dot(l,n) < EPSILON) {
        // The surface point is in shadow from the light.
        return ambient;
      }

      //
      // If the surface is matte, not glossy, then diffuse reflection.
      //
      float diffuseMix = 0.9;
      vec3  diffuse    = diffuseMix * lightColor * mColor * dot(l,n);
      if (mGlossy == 0) {
        return ambient + diffuse;
      }

      //
      // If glossy, then compute a specular highlight component.
      //
      float shininess   = 20.0;
      float specularMix = 0.3;
      //
      vec4  e = normalize(V - P);
      vec4  r = normalize(-l + 2.0 * dot(l,n) * n);
      float p = pow(max(dot(e,r),0.0), shininess);
      //
      vec3 specular = specularMix * lightColor * p * dot(l,n);
      return ambient + diffuse + specular;
    }

    ISect rayIntersectSphere(vec4 R, vec4 d, vec4 C, float r) {
      //
      // Check if a ray intersects a sphere.
      //
      //    R, d: ray source point and direction.
      //    C, r: sphere center point and radius
      //
      // Fill in the (non-material) information of an `ISect`
      // struct if the sphere is hit by the ray; return that
      // info.
      //
      
      vec4 du = normalize(d);
      vec4 toR = R-C;
      
      // This is calculated carefully on the wikipedia entry for
      // Ray-Sphere intersection.
      //
      float delta1 = -dot(du,toR);
      float delta2 = dot(toR,toR);
      float delta = delta1*delta1 - (delta2 - r*r);
      if (delta > EPSILON) {
        float distance = (delta1 - sqrt(delta));
        if (distance > EPSILON) {
          vec4 location = R + distance * du;
          //
          ISect isect;
          isect.yes      = 1;
          isect.distance = distance;
          isect.location = location;
          isect.normal   = normalize(location - C);
          return isect;
        }
      }
      return NO_INTERSECTION();
    }

    // CHECK_SPHERE_WITH_RAY
    //
    // Below gives the code for a C/GLSL _macro_ whose code gets
    // cut-n-pasted using its template. It is built as a single
    // line and gives a template for when it is used below.
    //
    // The code below checks whether a ray intersects a certain
    // sphere in the room scene. The particular sphere is given by
    // an integer INDEX and the sphere's info is accessed from the
    // `sphereData` array of floats. The INFO is expected to be
    // a variable of type `ISect` and it records an intersection,
    // if found, with that particular sphere. It only updates
    // that INFO if the intersection is found closer to the eye
    // point than the given info held by INFO.
    //
    // The ray is given by an ORIGIN point and DIRECTION vector.
    // The code relies on `rayIntersectSphere` to check inter-
    // section.
    //

    #define CHECK_SPHERE_WITH_RAY(INDEX, ORIGIN, DIRECTION, INFO)        \
    if (INDEX < numSpheres) {					                         \
    float cswr_x = sphereData[INDEX*7+0];                            \
    float cswr_y = sphereData[INDEX*7+1];                            \
    float cswr_z = sphereData[INDEX*7+2];                            \
    float cswr_r = sphereData[INDEX*7+3];                            \
    float cswr_R = sphereData[INDEX*7+4];                            \
    float cswr_G = sphereData[INDEX*7+5];                            \
    float cswr_B = sphereData[INDEX*7+6];                            \
    vec4  cswr_c = vec4(cswr_x,cswr_y,cswr_z,1.0);                   \
    ISect cswr;                                                      \
    cswr = rayIntersectSphere(ORIGIN, DIRECTION, cswr_c, cswr_r);    \
    cswr.materialColor = vec3(cswr_R,cswr_G,cswr_B);                 \
    cswr.materialGlossy = 1;                                         \
    INFO = bestISect(INFO, cswr);                                    \
  };

  ISect rayClosestSphere(vec4 R, vec4 d) {
    //
    // Checks each of the scene spheres, up to 10, to see
    // which of them (if any) are hit closest to the source
    // of some ray.
    //
    // The ray comes from point R in the direction d.
    //
    
    ISect isect = NO_INTERSECTION();
    // CHECK_SPHERE_WITH_RAY(0, R, d, isect); // Sphere #0 is a mirror.
    CHECK_SPHERE_WITH_RAY(1, R, d, isect);
    CHECK_SPHERE_WITH_RAY(2, R, d, isect);
    CHECK_SPHERE_WITH_RAY(3, R, d, isect);
    CHECK_SPHERE_WITH_RAY(4, R, d, isect);
    CHECK_SPHERE_WITH_RAY(5, R, d, isect);
    CHECK_SPHERE_WITH_RAY(6, R, d, isect);
    CHECK_SPHERE_WITH_RAY(7, R, d, isect);
    CHECK_SPHERE_WITH_RAY(8, R, d, isect);
    CHECK_SPHERE_WITH_RAY(9, R, d, isect);
    return isect;
  }

    vec4 subtractPoints(vec4 x, vec4 y){
      return vec4(x.x - y.x, x.y - y.y, x.z - y.z, x.w-y.w);
    }

    //int magnitudeVector(vec4 a){
    //  return Math.sqrt(a.x **2 + a.y**2 + a.z**2 + a.w ** 2);
    //}

    vec4 cross(vec4 a, vec4 b){
      return vec4(a.y*b.z - a.z*b.y, a.y*b.z - a.x*b.z, a.x*b.y - a.y*b.x,0);
    }

    vec4 reverseVector(vec4 a){
      return vec4(-1.0 * a.x, -1.0 * a.y, -1.0 * a.z, -1.0 * a.w);
      //return vec4(0,0,0,0);
    }

    bool insideRectangle(vec4 P, vec4 left, vec4 right, vec4 up){
     // P: the point we are checking 
     // left, right: bottom two points of the rectangle
     // up: either upper corner of the rectangle
     if(P.x < left.x) return false;
     if (P.x > right.x) return false;
     if (P.y < left.y) return false;
     if (P.y > up.y) return false;
     return true;
    }

    struct vec2Tuple{
      vec2 one;
      vec2 two;
    };

    //vec2 vec2Midpoint(vec2 a, vec2b){
    // return vec2((a.x+b.x)/2,(a.y+b.y)/2);
    //}
    
    float bezierComponent(float t, float c0, float c1, float c2){
      // c1, c2, c3: the three components, x or z, of our control points
      float first = (1.0 -t) * (1.0 -t) * c0;
      float second = 2.0 * (1.0 -t) * t * c1;
      float third = t * t * c2;
      return first + second + third;
    }
    
    ISect rayIntersectBezier(vec4 R, vec4 d, vec2 cp0, vec2 cp1, vec2 cp2) {
      //
      // This should return intersection information that results
      // from shooting a ray from point `R` in a direction `d`,
      // possibly hitting a Bezier mirror. If the mirror is hit,
      // then the ISect struct should contain the location point
      // where it was hit, the surface normal where it was hit,
      // and its distance from the point along that ray. The `yes`
      // component of the `ISect` should be set to 1.
      //
      // If they don't intersect, return NO_INTERSECTION().
      //
      // The mirror is given by control points whose floor
      // coordinates sit at `cp0`, `cp1`, and `cp2`. You can make
      // the mirror have any height you like. My demo used a
      // height of 1.5.
      //

      const int panelNum = 16;
      // our array of points on the segemented bezier curve
      vec2 curvePoints[panelNum];
      // looping from t [0,1] to get our segemented bezier curve points
      for (float t = 0.0; t <= 1.0; t += 1.0/float(panelNum)){
        float x = bezierComponent(t, cp0.x, cp1.x, cp2.x);
        float z = bezierComponent(t, cp0.y, cp1.y, cp2.y);
        curvePoints[int(t * float(panelNum))] = vec2(x,z);
      }
      // loop through each panel of our mirror
      for(int i = 1; i < panelNum -1; i++){
        // control points of our segement
        vec2 cpOne = curvePoints[i];
        vec2 cpTwo = curvePoints[i+1];

        // three points on our segement
        vec4 one = vec4(cpOne.x, 0, cpOne.y, 0);
        vec4 two = vec4(cpTwo.x, 0, cpTwo.y, 0);
        vec4 three = vec4(cpOne.x, 1.5, cpOne.y, 0);
	vec4 four = vec4(cpTwo.x, 1.5, cpTwo.y, 0);

        // two vectors that determine our panel
        vec4 twoMinusOne = subtractPoints(two, one);
        vec4 threeMinusOne = subtractPoints(three, one);

        // normal of our panel, which is reversed at first for a minute
        vec4 normal = normalize(cross(twoMinusOne, threeMinusOne));
        normal = reverseVector(normal);

        // intersection with the plane composed of the three points of our segement
        ISect intPlane = rayIntersectPlane(R, d, one, normal);

        // check to see if it insersects our plane inside our segment

        bool inside = insideRectangle(intPlane.location, one, two, three);
        //control points of the previous and next segments
	      vec2 cpPrev = curvePoints[i-1];
	      vec2 cpNext = curvePoints[i+2];
	      //we then take the bottom left and top left points of the previous segment
	      //and the bottom right and top right of the next segment
	
	      vec4 prevBottom = vec4(cpPrev.x, 0, cpPrev.y, 0);
	      vec4 prevTop = vec4(cpPrev.x, 1.5, cpPrev.y, 0);
	      vec4 nextBottom = vec4(cpNext.x, 0, cpNext.y, 0);
	      vec4 nextTop = vec4(cpNext.x, 1.5, cpNext.y, 0);
	      
	      //then we take the norms of the previous and next segments
	      vec4 prevNorm = getReversedNormal(prevBottom, one, prevTop);
	      vec4 nextNorm = getReversedNormal(two, nextBottom, four); 
	      if(inside){
		 //the collision with the plane is inside the segment
		 //now we just need to compute the average normal of the next and prev segment
		 float widthSegment = two.x - one.x;
		 float alpha = (intPlane.location.x - one.x) / widthSegment;
		 intPlane.normal = alpha * prevNorm + (1.0 - alpha) * nextNorm;
                 return intPlane;
	      }

      }
      return NO_INTERSECTION();
    }

   ISect rayIntersectMirror(vec4 R, vec4 d) {
    //
    // Checks whether a ray hits the one mirrored object in the
    // scene. Currently, this is a sphere. Your assignment is to
    // change this code to check intersection with a curved
    // mirror.
    //
    // The ray comes from point R in the direction d.
    //

    ISect isect = NO_INTERSECTION();

    //
    // Right now, checks intersection with Sphere #0.
    //
    if (curvedMirror == 0) {
      CHECK_SPHERE_WITH_RAY(0, R, d, isect);
    } else {
      vec2 cp0 = vec2(controlPoints[0],controlPoints[1]);
      vec2 cp1 = vec2(controlPoints[2],controlPoints[3]);
      vec2 cp2 = vec2(controlPoints[4],controlPoints[5]);
      isect = rayIntersectBezier(R, d, cp0, cp1, cp2);
    }

    return isect;
  }

  vec3 trace(vec4 R, vec4 d) {
    //
    // Traces a ray from the eye point R, through the virtual
    // screen pixel in direction d out into the scene.  The
    // scene consists of a collection of spheres, one mirrored
    // surface, and a cubicle room. It has one point light
    // source sitting in the room.
    //
    // The ray comes from point R in the direction d.
    //
    // It traces 2 or 3 rays, depending on what's hit by the
    // primary ray.
    //
    // It shoots only two rays when the primary ray directly
    // hits a glossy object (a sphere) or a matte room bounding
    // surface (e.g. wall, ceiling). In this case, a RGB color
    // is returned. That color is computed as Phong
    // illumination, though that object might be in shadow from
    // the light.  This check for shadowing is made by shooting
    // a secondary ray from the surface point to the light
    // source, seeing if any object is hit.
    //
    // It shoots three rays when the primary ray hits a mirrored
    // surface. In that case a secondary reflection ray is
    // shot much in the same way the primary ray is shot as
    // described above, in order to see what matte/glossy object
    // is hit.
    //
    // (Note: This would normally be written recursively but
    //  GLSL does not allow that, so as to work well on GPU
    //  hardware.)

    //
    // See if it hits the mirrored object...
    // 
    ISect mirror = rayIntersectMirror(R,d);

    //
    // If it does not hit the mirror, we see what object the
    // primary ray hits.
    //
    vec4 source = R;
    vec4 direction = d;

    //
    // If it does hit the mirror, and nothing is blocking that
    // ray from hitting the mirror, instead send a secondary ray
    // due to reflection to see what object *it* hits.
    //
    if (mirror.yes == 1) {
      bool blocked = rayHitsSomeSphereBefore(mirror.location, -d, FAR);
      if (!blocked) {
        //
        // Compute the reflected ray.
        //
        source = mirror.location;
        vec4 n = normalize(mirror.normal);
        direction = normalize(d - 2.0 * dot(d,n) * n);
      }
    }

    // Find out the color of the surface hit...

    //
    // If nothing gets hit, set to some background color.
    // (Make notable because we expect *something* to be hit.)
    //
    vec3 color = vec3(1.0,0.8,0.0);

    //
    // Does it hit any of the spheres in the scene?
    //
    ISect sphere = rayClosestSphere(source,direction);
    //
    // What wall does it hit?
    //
    ISect wall = rayClosestWall(source, direction);
    //
    // Which is closer?
    //
    ISect isect = bestISect(wall,sphere);
    //
    // Compute the color bouncing off that surface....
    //
    if (isect.yes == 1) {
      color = computePhong(isect.location, isect.normal,
      source, lightPosition,
      isect.materialColor,
      isect.materialGlossy);
    }
    return color;
  }


  //
  // main
  //
  // GLSL to perform ray tracing of a simple scene.
  //
  // Shoots rays from an eye point `eyePosition` out through a
  // pixel as specified by the vec2 `jitter`, using the orthonormal
  // basis of direction vectors given by
  //
  //  * into-/right-/up-Direction
  //
  // to determine the direction of the ray(s).
  //
  // A SAMPLES x SAMPLES collection of rays are sent through the
  // pixel in the pattern of a regularly spaced grid.
  //
  // The result of this series of traced rays is an averaged RGB
  // value, averaged from the Phong shading and reflection
  // determined from the objects hit by the ray into the scene.
  //
  // Through GLSL, that average RGB value is painted as the pixel
  // in the WebGL display.

  #define SAMPLES  2
  #define FSAMPLES 2.0

  void main(void) {
    float delta = 1.0 / FSAMPLES / 512.0;
    vec3 color = vec3(0.0,0.0,0.0);

    //
    // Shoot a SAMPLES x SAMPLES array of rays for this pixel.
    //
    float dx = 0.0;
    for (int xoffset = 0; xoffset < SAMPLES; xoffset++) {
      float dy = 0.0;
      for (int yoffset = 0; yoffset < SAMPLES; yoffset++) {

        //
        // Trace a ray from the eye, into the scene.
        //
        
        //
        // Offset the ray slightly from the pixel center.
        //
        vec4 rayDirection = intoDirection
        + (jitter.x + dx) * rightDirection
        + (jitter.y + dy) * upDirection;

        //
        // See what color would hit the eye. Add it to
        // this pixel's average of colors.
        //
        color += trace(eyePosition, rayDirection);

        dy += delta;
      }
      dx += delta;
    }

    //
    // Compute the average color found by each traced ray.
    //
    color = color * (1.0 / FSAMPLES / FSAMPLES);

    //
    // Tell WebGL the color computed for this pixel.
    //
    gl_FragColor = vec4(color, 1.0);
  }
</script>


<script id="glsl/vs-varying-color.c" type="x-shader/x-vertex">
  //
  // vs-varying-color.c
  //
  // Reed College CSCI 385 Computer Graphics Spring 2022
  //
  // Simple vertex shader that preprocesses per-vertex information for a
  // fragment shader. It expects the color information to vary amongst
  // the vertices of the object.
  //
  // It calculates a position using the supplied vertex positions and the two
  // standard WebGL transforation matrices.
  //
  // It sends the (interpolated) color information to the fragment shader.
  //
  attribute vec4 aVertexPosition;
  attribute vec4 aVertexColor;

  uniform mat4 uModelViewMatrix;
  uniform mat4 uProjectionMatrix;

  varying vec4 color;

  void main(void) {
    gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
    color = aVertexColor;
  }
</script>
<script id="glsl/fs-color.c" type="x-shader/x-fragment">
  //
  // fs-color.c
  //
  // Reed College CSCI 385 Computer Graphics Speing 2022
  //
  // Simple fragment shader that gets fed a color from the vertex shader.
  // Nothing else is communicated to it from the WebGL program.
  //
  varying lowp vec4 color;

  void main(void) {
    gl_FragColor = color;
  }
</script>
<script id="glsl/vs-uniform-material.c" type="x-shader/x-vertex">
  //
  // vs-uniform-material.c
  //
  // Reed College CSCI 385 Computer Graphics Speing 2022
  //
  // Vertex shader that preprocesses per-vertex information to be fed
  // into a Phong fragment shader. It expects the material's color
  // information to be uniform over all the vertices of the object.
  //
  // It sends this (interpolated) information to the fragment shader:
  // * The position of a fragment of a facet or line object defined by
  //   several vertex positions.
  // * The normal of that surface.
  // * The color of the material.
  //
  // It is fed per-vertex information with attributes for:
  // * vertex position
  // * surface normal at that vertex
  // * material color at that vertex
  //
  attribute vec4 aVertexPosition;   // Corner of some facet of the surface.
  attribute vec4 aVertexNormal;     // Surface normal at that osition.

  uniform mat4 uProjectionMatrix;
  uniform mat4 uModelViewMatrix;
  uniform vec4 uMaterialColor;      // Color of material.

  varying vec4 position;   // Fragment's surface position.
  varying vec4 normal;     // Fragment's surface normal.
  varying vec4 material;   // Fragment surface's material color.
  varying vec4 place;
  void main() {

    // Transform and interpolate vertex information.
    position   = uModelViewMatrix * aVertexPosition;
    normal     = uModelViewMatrix * aVertexNormal;
    material   = uMaterialColor;

    // The output required by GLSL.
    gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;

    place = gl_Position;
  }
</script>
<script id="glsl/vs-varying-material.c" type="x-shader/x-vertex">
  //
  // vs-varying-material.c
  //
  // Reed College CSCI 385 Computer Graphics Speing 2022
  //
  // Vertex shader that preprocesses per-vertex information to be fed
  // into a Phong fragment shader. It expects the material's color
  // information to vary amongst the vertices of the object.
  //
  // It sends this (interpolated) information to the fragment shader:
  // * The position of a fragment of a facet or line object defined by
  //   several vertex positions.
  // * The normal of that surface.
  // * The color of the material.
  //
  // It is fed per-vertex information with attributes for:
  // * vertex position
  // * surface normal at that vertex
  // * material color at that vertex
  //
  attribute vec4 aVertexPosition;   // Corner of some facet of the surface.
  attribute vec4 aVertexNormal;     // Surface normal at that position.
  attribute vec4 aVertexMaterial;   // Color of material at that position.

  uniform mat4 uProjectionMatrix;
  uniform mat4 uModelViewMatrix;

  varying vec4 position;   // Fragment's surface position.
  varying vec4 normal;     // Fragment's surface normal.
  varying vec4 material;   // Fragment surface's material color.
  varying vec4 place;

  void main() {

    // Transform and interpolate vertex information.
    position   = uModelViewMatrix * aVertexPosition;
    normal     = uModelViewMatrix * aVertexNormal;
    material   = aVertexMaterial;

    // The output required by GLSL.
    gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
    place = gl_Position;

  }
</script>
<script id="glsl/fs-phong.c" type="x-shader/x-fragment">
  //
  // fs-phong.c
  //
  // Reed College CSCI 385 Computer Graphics Speing 2022
  //
  // Fragment shader that performs a variant of Phong shading.
  //
  // It is fed position, material color, and normal info from the vertex shader.
  // It is also fed the following uniform information from the WebGL program:
  //  * The color of the ambient light.
  //  * Characteristics of a single light source (LIGHT0), namely:
  //    + its color
  //    + its position
  //    + whether (the specular component of) that light is on/off
  //  * The reflectance characteristics of the matrial, namely:
  //    + how much of it is diffuse
  //    + how much of it is specular
  //    + how shiny the surface is ("shininess" as employed by the Phong model)
  // It uses all this info to calculate the fragment color at its surface point.
  //

  precision highp float;

  varying vec4 position;   // Fragment's surface position.
  varying vec4 normal;     // Fragment's surface normal.
  varying vec4 material;   // Fragment surface's material color.

  varying vec4 place;

  uniform int  uLight0Enabled;  // Is the light on?
  uniform vec4 uLight0Position; // Location of the light.
  uniform vec4 uLight0Color;    // Light color.

  uniform vec4 uAmbientColor;    // Ambient light of environment.

  uniform float uMaterialDiffuse;   // Portion of reflection that's diffuse.
  uniform float uMaterialSpecular;  // Portion of reflection that's specular.
  uniform float uMaterialShininess; // Specular highlight control.

  void main() {

    vec4 light_color         = uLight0Color;
    vec4 ambient_light_color = uAmbientColor;

    float diffuse_amount  = uMaterialDiffuse;
    float specular_amount = uMaterialSpecular;
    float shininess       = uMaterialShininess;

    vec4 light = uLight0Position;
    vec4 eye   = vec4(0.0,0.0,10.0,1.0);

    vec4  l = normalize(light - position);
    vec4  e = normalize(eye - position);
    vec4  n = normalize(normal);
    vec4  r = normalize(-l + 2.0 * dot(l,n) * n);
    float p = pow(max(dot(e,r),0.0),shininess);

    vec4 ambient  = ambient_light_color * material;
    vec4 diffuse  = diffuse_amount * light_color * material * max(dot(l,n), 0.0);
    vec4 specular = specular_amount * light_color * p * max(dot(l,n), 0.0);

    if (dot(l,n) > 0.0) {
      if (uLight0Enabled == 1) {
        gl_FragColor = ambient + diffuse + specular;
      } else {
        gl_FragColor = ambient + diffuse;
      }
    } else {
      gl_FragColor = ambient;
    }
  }
</script>

<script id="glsl/vs-uniform-color.c" type="x-shader/x-vertex">
  //
  // vs-uniform-color.c
  //
  // Reed College CSCI 385 Computer Graphics Spring 2022
  //
  // Simple vertex shader that preprocesses per-vertex information for a
  // fragment shader. It uses the same color information uniformly for
  // all the vertices of the object.
  //
  // It calculates a position using the supplied vertex positions and the two
  // standard WebGL transforation matrices.
  //
  // It sends the color information to the fragment shader.
  //
  attribute vec4 aVertexPosition;

  uniform mat4 uModelViewMatrix;
  uniform mat4 uProjectionMatrix;
  uniform vec4 uColor;

  varying vec4 color;

  void main(void) {
    gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
    color = uColor;
  }
</script>
<script id="glsl/vs-varying-color.c" type="x-shader/x-vertex">
  //
  // vs-varying-color.c
  //
  // Reed College CSCI 385 Computer Graphics Speing 2022
  //
  // Simple vertex shader that preprocesses per-vertex information for a
  // fragment shader. It expects the color information to vary amongst
  // the vertices of the object.
  //
  // It calculates a position using the supplied vertex positions and the two
  // standard WebGL transforation matrices.
  //
  // It sends the (interpolated) color information to the fragment shader.
  //
  attribute vec4 aVertexPosition;
  attribute vec4 aVertexColor;

  uniform mat4 uModelViewMatrix;
  uniform mat4 uProjectionMatrix;

  varying vec4 color;

  void main(void) {
    gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
    color = aVertexColor;
  }
</script>
<script id="glsl/fs-color.c" type="x-shader/x-fragment">
  //
  // fs-color.c
  //
  // Reed College CSCI 385 Computer Graphics Speing 2022
  //
  // Simple fragment shader that gets fed a color from the vertex shader.
  // Nothing else is communicated to it from the WebGL program.
  //
  varying lowp vec4 color;

  void main(void) {
    gl_FragColor = color;
  }
</script>
<script id="glsl/vs-uniform-material.c" type="x-shader/x-vertex">
  //
  // vs-uniform-material.c
  //
  // Reed College CSCI 385 Computer Graphics Speing 2022
  //
  // Vertex shader that preprocesses per-vertex information to be fed
  // into a Phong fragment shader. It expects the material's color
  // information to be uniform over all the vertices of the object.
  //
  // It sends this (interpolated) information to the fragment shader: 
  // * The position of a fragment of a facet or line object defined by
  //   several vertex positions.
  // * The normal of that surface.
  // * The color of the material.
  //
  // It is fed per-vertex information with attributes for:
  // * vertex position
  // * surface normal at that vertex
  // * material color at that vertex
  //
  attribute vec4 aVertexPosition;   // Corner of some facet of the surface.
  attribute vec4 aVertexNormal;     // Surface normal at that osition.

  uniform mat4 uProjectionMatrix;
  uniform mat4 uModelViewMatrix;
  uniform vec4 uMaterialColor;      // Color of material.

  varying vec4 position;   // Fragment's surface position.
  varying vec4 normal;     // Fragment's surface normal.
  varying vec4 material;   // Fragment surface's material color. 
  varying vec4 place; 
  void main() {

    // Transform and interpolate vertex information.
    position   = uModelViewMatrix * aVertexPosition;
    normal     = uModelViewMatrix * aVertexNormal;
    material   = uMaterialColor;

    // The output required by GLSL.
    gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;

    place = gl_Position;
  }
</script>
<script id="glsl/vs-varying-material.c" type="x-shader/x-vertex">
  //
  // vs-varying-material.c
  //
  // Reed College CSCI 385 Computer Graphics Speing 2022
  //
  // Vertex shader that preprocesses per-vertex information to be fed
  // into a Phong fragment shader. It expects the material's color
  // information to vary amongst the vertices of the object.
  //
  // It sends this (interpolated) information to the fragment shader:
  // * The position of a fragment of a facet or line object defined by
  //   several vertex positions.
  // * The normal of that surface.
  // * The color of the material.
  //
  // It is fed per-vertex information with attributes for:
  // * vertex position
  // * surface normal at that vertex
  // * material color at that vertex
  //
  attribute vec4 aVertexPosition;   // Corner of some facet of the surface.
  attribute vec4 aVertexNormal;     // Surface normal at that position.
  attribute vec4 aVertexMaterial;   // Color of material at that position.

  uniform mat4 uProjectionMatrix;
  uniform mat4 uModelViewMatrix;

  varying vec4 position;   // Fragment's surface position.
  varying vec4 normal;     // Fragment's surface normal.
  varying vec4 material;   // Fragment surface's material color.
  varying vec4 place;

  void main() {

    // Transform and interpolate vertex information.
    position   = uModelViewMatrix * aVertexPosition;
    normal     = uModelViewMatrix * aVertexNormal;
    material   = aVertexMaterial;

    // The output required by GLSL.
    gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
    place = gl_Position;    

  }
</script>
<script id="glsl/fs-phong.c" type="x-shader/x-fragment">
  //
  // fs-phong.c
  //
  // Reed College CSCI 385 Computer Graphics Speing 2022
  //
  // Fragment shader that performs a variant of Phong shading.
  //
  // It is fed position, material color, and normal info from the vertex shader.
  // It is also fed the following uniform information from the WebGL program:
  //  * The color of the ambient light.
  //  * Characteristics of a single light source (LIGHT0), namely:
  //    + its color
  //    + its position
  //    + whether (the specular component of) that light is on/off
  //  * The reflectance characteristics of the matrial, namely:
  //    + how much of it is diffuse
  //    + how much of it is specular
  //    + how shiny the surface is ("shininess" as employed by the Phong model)
  // It uses all this info to calculate the fragment color at its surface point.
  //

  precision highp float;

  varying vec4 position;   // Fragment's surface position.
  varying vec4 normal;     // Fragment's surface normal.
  varying vec4 material;   // Fragment surface's material color.

  varying vec4 place;      

  uniform int  uLight0Enabled;  // Is the light on?
  uniform vec4 uLight0Position; // Location of the light.
  uniform vec4 uLight0Color;    // Light color.

  uniform vec4 uAmbientColor;    // Ambient light of environment.

  uniform float uMaterialDiffuse;   // Portion of reflection that's diffuse.
  uniform float uMaterialSpecular;  // Portion of reflection that's specular.
  uniform float uMaterialShininess; // Specular highlight control.

  void main() {

    vec4 light_color         = uLight0Color;
    vec4 ambient_light_color = uAmbientColor;

    float diffuse_amount  = uMaterialDiffuse;
    float specular_amount = uMaterialSpecular;
    float shininess       = uMaterialShininess;

    vec4 light = uLight0Position;
    vec4 eye   = vec4(0.0,0.0,10.0,1.0);

    vec4  l = normalize(light - position);
    vec4  e = normalize(eye - position);
    vec4  n = normalize(normal);
    vec4  r = normalize(-l + 2.0 * dot(l,n) * n);
    float p = pow(max(dot(e,r),0.0),shininess);

    vec4 ambient  = ambient_light_color * material;
    vec4 diffuse  = diffuse_amount * light_color * material * max(dot(l,n), 0.0);
    vec4 specular = specular_amount * light_color * p * max(dot(l,n), 0.0);

    if (dot(l,n) > 0.0) {
      if (uLight0Enabled == 1) {
        gl_FragColor = ambient + diffuse + specular;
      } else {
        gl_FragColor = ambient + diffuse;
      }
    } else {
      gl_FragColor = ambient;
    }
  }
</script>


<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/1.4.0/jspdf.min.js"></script>

<script src="gl-matrix-min.js" defer></script>
<script src="gl.js" defer></script>
<script src="load-shaders.js" defer></script>
<script src="opengl.js" defer></script>
<script src="geometry-3d.js" defer></script>
<script src="funhouse.js" defer></script>
<script src="bezier-funhouse.js" defer></script>
<script type="text/javascript">
  function chooseMirror(){
    const status = document.getElementById("mirror-select").innerText;
    if (status == "sphere -> bezier") {
      document.getElementById("mirror-select").innerText = "bezier -> sphere";
      sphericalMirror(false);
    } else {
      document.getElementById("mirror-select").innerText = "sphere -> bezier";
      sphericalMirror(true);
    }
  }
</script>
</head>

<body>
  <canvas id="glcanvas" width="1024" height="512"></canvas><br>
  <font face="Verdana">
    <button onClick="chooseColor('adriatic')">adriatic</button>
    <button onClick="chooseColor('jade')">jade</button>
    <button onClick="chooseColor('travertine')">travertine</button>
    <button onClick="chooseColor('amethyst')">amethyst</button>
    <button onClick="chooseColor('fireball')">fireball</button>
    mirror:
    <button value="sphere -> bezier" id="mirror-select" onclick="chooseMirror();">sphere -> bezier</button>
    <br>
    Place spheres or else position a <b>Bézier funhouse mirror</b>.<br>
    Use `ijklaz` to control the light position.<br>
    Use `x` to delete a sphere.<br>
    SHIFT-click to control the curve of the funhouse mirror.<br>
  </body>
  </html>
